<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="MySQL 进阶, 王斌的博客,HTML,CSS,JavaScript,JQuery,java,linux等">
    <meta name="description" content="MySQL 是一款安全、跨平台、高效的，并与 PHP、Java 等主流编程语言紧密结合的数据库系统。">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>MySQL 进阶 | 王斌的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="王斌的博客" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
       background-repeat:no-repeat;
       background-size: 100% 100%;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">王斌的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">王斌的博客</div>
        <div class="logo-desc">
            
            本网站是个人兴趣爱好，总结分享经验，记录生活点滴的平台
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/images/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">MySQL 进阶</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="container content">

    
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/MySQL-%E8%BF%9B%E9%98%B6/">
                                <span class="chip bg-color">MySQL 进阶</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-category">
                                数据库
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-05-15
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-04-06
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    27k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    100 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1. 存储引擎"></a>1. 存储引擎</h1><h2 id="1-1-MySQL体系结构"><a href="#1-1-MySQL体系结构" class="headerlink" title="1.1 MySQL体系结构"></a>1.1 MySQL体系结构</h2><p><img src="/images/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg" alt="MySQL体系结构"></p>
<p>1). 连接层<br>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。<br>2). 服务层<br>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。<br>3). 引擎层<br>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。<br>4). 存储层<br>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p>
<p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<h2 id="1-2-存储引擎介绍"><a href="#1-2-存储引擎介绍" class="headerlink" title="1.2 存储引擎介绍"></a>1.2 存储引擎介绍</h2><p><img src="/images/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D.jpg" alt="存储引擎介绍"><br>大家可能没有听说过存储引擎，但是一定听过引擎这个词，引擎就是发动机，是一个机器的核心组件。比如，对于舰载机、直升机、火箭来说，他们都有各自的引擎，是他们最为核心的组件。而我们在选择引擎的时候，需要在合适的场景，选择合适的存储引擎，就像在直升机上，我们不能选择舰载机的引擎一样。<br>而对于存储引擎，也是一样，他是mysql数据库的核心，我们也需要在合适的场景选择合适的存储引擎。接下来就来介绍一下存储引擎。<br>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。<br>1). 建表时指定存储引擎</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">CREATE TABLE 表名<span class="token punctuation">(</span>
字段<span class="token number">1</span> 字段<span class="token number">1</span>类型 <span class="token punctuation">[</span> COMMENT 字段<span class="token number">1</span>注释 <span class="token punctuation">]</span> <span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
字段n 字段n类型 <span class="token punctuation">[</span>COMMENT 字段n注释 <span class="token punctuation">]</span>
<span class="token punctuation">)</span> ENGINE <span class="token operator">=</span> INNODB <span class="token punctuation">[</span> COMMENT 表注释 <span class="token punctuation">]</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>2). 查询当前数据库支持的存储引擎</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">show engines<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>示例演示:<br>A. 查询建表语句 — 默认存储引擎: InnoDB</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">show create table account<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/images/%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.jpg" alt="默认存储引擎"><br>我们可以看到，创建表时，即使我们没有指定存储疫情，数据库也会自动选择默认的存储引擎。<br>B. 查询当前数据库支持的存储引擎</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">show engines <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/images/%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E1.jpg" alt="默认存储引擎1"><br>C. 创建表 my_myisam , 并指定MyISAM存储引擎</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">screate table <span class="token function">my_myisam</span><span class="token punctuation">(</span>
  id <span class="token keyword">int</span><span class="token punctuation">,</span>
  name <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> engine <span class="token operator">=</span> <span class="token class-name">MyISAM</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>D. 创建表 my_memory , 指定Memory存储引擎</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">create table <span class="token function">my_memory</span><span class="token punctuation">(</span>
  id <span class="token keyword">int</span><span class="token punctuation">,</span>
  name <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> engine <span class="token operator">=</span> <span class="token class-name">Memory</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="1-3-存储引擎特点"><a href="#1-3-存储引擎特点" class="headerlink" title="1.3 存储引擎特点"></a>1.3 存储引擎特点</h2><p>上面我们介绍了什么是存储引擎，以及如何在建表时如何指定存储引擎，接下来我们就来介绍下来上面重点提到的三种存储引擎 InnoDB、MyISAM、Memory的特点。</p>
<h3 id="1-3-1-InnoDB"><a href="#1-3-1-InnoDB" class="headerlink" title="1.3.1 InnoDB"></a>1.3.1 InnoDB</h3><p>1). 介绍<br>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。<br>2). 特点</p>
<ul>
<li>DML操作遵循ACID模型，支持事务；</li>
<li>行级锁，提高并发访问性能；</li>
<li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</li>
</ul>
<p>3). 文件<br>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。<br>参数：innodb_file_per_table</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">show variables like 'innodb_file_per_table'<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/images/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E1.jpg" alt="存储引擎1"><br>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 我们直接打开MySQL的数据存放目录： C:\ProgramData\MySQL\MySQL Server 8.0\Data ， 这个目录下有很多文件夹，不同的文件夹代表不同的数据库，我们直接打开itcast文件夹。<br><img src="/images/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E2.jpg" alt="存储引擎2"><br>可以看到里面有很多的ibd文件，每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。<br><img src="/images/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E3.jpg" alt="存储引擎3"><br>4). 逻辑存储结构<br><img src="/images/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg" alt="逻辑存储结构"></p>
<ul>
<li>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。</li>
<li>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</li>
<li>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</li>
<li>页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li>
<li>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。</li>
</ul>
<h3 id="1-3-2-MyISAM"><a href="#1-3-2-MyISAM" class="headerlink" title="1.3.2 MyISAM"></a>1.3.2 MyISAM</h3><p>1). 介绍<br>MyISAM是MySQL早期的默认存储引擎。<br>2). 特点<br>不支持事务，不支持外键<br>支持表锁，不支持行锁<br>访问速度快<br>3). 文件<br>xxx.sdi：存储表结构信息<br>xxx.MYD: 存储数据<br>xxx.MYI: 存储索引</p>
<h3 id="1-3-3-Memory"><a href="#1-3-3-Memory" class="headerlink" title="1.3.3 Memory"></a>1.3.3 Memory</h3><p>1). 介绍<br>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。<br>2). 特点<br>内存存放<br>hash索引（默认）<br>3).文件<br>xxx.sdi：存储表结构信息</p>
<h3 id="1-3-4-区别及特点"><a href="#1-3-4-区别及特点" class="headerlink" title="1.3.4 区别及特点"></a>1.3.4 区别及特点</h3><table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>支持</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>锁机制</td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>—</td>
<td>—</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>支持</td>
<td>—</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>支持</td>
<td>—</td>
<td>—</td>
</tr>
</tbody></table>
<p>面试题:</p>
<ul>
<li>InnoDB引擎与MyISAM引擎的区别 ?</li>
<li>①. InnoDB引擎, 支持事务, 而MyISAM不支持。</li>
<li>②. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。</li>
<li>③. InnoDB引擎, 支持外键, 而MyISAM是不支持的。<br>主要是上述三点区别，当然也可以从索引结构、存储限制等方面，更加深入的回答，具体参考如下官方文档：<br><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html</a><br><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html">https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html</a></li>
</ul>
<h2 id="1-4-存储引擎选择"><a href="#1-4-存储引擎选择" class="headerlink" title="1.4 存储引擎选择"></a>1.4 存储引擎选择</h2><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<ul>
<li>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li>
<li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li>
<li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</li>
</ul>
<h1 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h1><h2 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h2><h3 id="2-1-1-介绍"><a href="#2-1-1-介绍" class="headerlink" title="2.1.1 介绍"></a>2.1.1 介绍</h3><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。<br><img src="/images/%E7%B4%A2%E5%BC%95.jpg" alt="索引"><br>一提到数据结构，大家都会有所担心，担心自己不能理解，跟不上节奏。不过在这里大家完全不用担心，我们后面在讲解时，会详细介绍。</p>
<h2 id="2-2-演示"><a href="#2-2-演示" class="headerlink" title="2.2 演示"></a>2.2 演示</h2><p>表结构及其数据如下：<br><img src="/images/%E8%A1%A8%E7%BB%93%E6%9E%84.jpg" alt="表结构"><br>假如我们要执行的SQL语句为 ： select * from user where age = 45;<br>1). 无索引情况<br><img src="/images/%E6%97%A0%E7%B4%A2%E5%BC%95%E6%83%85%E5%86%B5.jpg" alt="无索引情况"><br>在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很低。<br>2). 有索引情况<br>如果我们针对于这张表建立了索引，假设索引结构就是二叉树，那么也就意味着，会对age这个字段建立一个二叉树的索引结构。<br><img src="/images/%E6%9C%89%E7%B4%A2%E5%BC%95%E6%83%85%E5%86%B5.jpg" alt="有索引情况"><br>此时我们在进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率。<br>备注：这里我们只是假设索引的结构是二叉树，介绍一下索引的大概原理，只是一个示意图，并不是索引的真实结构，索引的真实结构，后面会详细介绍。</p>
<h2 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2.3 特点"></a>2.3 特点</h2><table>
<thead>
<tr>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td>提高数据检索的效率，降低数据库的IO成本</td>
<td>索引列也是要占用空间的。</td>
</tr>
<tr>
<td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</td>
<td>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。</td>
</tr>
</tbody></table>
<h2 id="2-2-索引结构"><a href="#2-2-索引结构" class="headerlink" title="2.2 索引结构"></a>2.2 索引结构</h2><h3 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1 概述"></a>2.2.1 概述</h3><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>B+Tree索引</td>
<td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td>
</tr>
<tr>
<td>Hash索引</td>
<td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询</td>
</tr>
<tr>
<td>R-tree(空间索引）</td>
<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td>Full-text(全文索引)</td>
<td>是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES</td>
</tr>
</tbody></table>
<p>上述是MySQL中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持情况。</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree 索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p>注意： 我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</p>
<h3 id="2-2-2-二叉树"><a href="#2-2-2-二叉树" class="headerlink" title="2.2.2 二叉树"></a>2.2.2 二叉树</h3><p>假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5.jpg" alt="主键顺序插入"><br>如果主键是顺序插入的，则会形成一个单向链表，结构如下：<br><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="二叉树"><br>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p>
<ul>
<li>顺序插入时，会形成一个链表，查询性能大大降低。</li>
<li>大数据量情况下，层级较深，检索速度慢。<br>此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下:<br><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" alt="红黑树"><br>但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：</li>
<li>大数据量情况下，层级较深，检索速度慢。<br>所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree，那么什么是B+Tree呢？在详解B+Tree之前，先来介绍一个B-Tree。</li>
</ul>
<h3 id="2-2-3-B-Tree"><a href="#2-2-3-B-Tree" class="headerlink" title="2.2.3 B-Tree"></a>2.2.3 B-Tree</h3><p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针：<br><img src="/images/B-Tree.jpg" alt="B-Tree"><br>知识小贴士: 树的度数指的是一个节点的子节点个数。<br>我们可以通过一个数据结构可视化的网站来简单演示一下。 <a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a><br>插入一组数据： 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 。然后观察一些数据插入过程中，节点的变化情况。<br><img src="/images/%E8%8A%82%E7%82%B9%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.jpg" alt="节点的变化情况"><br>特点：</p>
<ul>
<li>5阶的B树，每一个节点最多存储4个key，对应5个指针。</li>
<li>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</li>
<li>在B树中，非叶子节点和叶子节点都会存放数据。</li>
</ul>
<h3 id="2-2-4-B-Tree"><a href="#2-2-4-B-Tree" class="headerlink" title="2.2.4 B+Tree"></a>2.2.4 B+Tree</h3><p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：<br><img src="/images/B+Tree.jpg" alt="B+Tree"><br>我们可以看到，两部分：</p>
<ul>
<li>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</li>
<li>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。<br>我们可以通过一个数据结构可视化的网站来简单演示一下。 <a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a><br>插入一组数据： 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 。然后观察一些数据插入过程中，节点的变化情况。<br><img src="/images/%E8%8A%82%E7%82%B9%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.jpg" alt="节点变化情况"><br>最终我们看到，B+Tree 与 B-Tree相比，主要有以下三点区别：</li>
<li>所有的数据都会出现在叶子节点。</li>
<li>叶子节点形成一个单向链表。</li>
<li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。<br>上述我们所看到的结构是标准的B+Tree的数据结构，接下来，我们再来看看MySQL中优化之后的B+Tree。<br>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。<br><img src="/images/%E4%BC%98%E5%8C%96.jpg" alt="优化"></li>
</ul>
<h3 id="2-2-5-Hash"><a href="#2-2-5-Hash" class="headerlink" title="2.2.5 Hash"></a>2.2.5 Hash</h3><p>MySQL中除了支持B+Tree索引，还支持一种索引类型—Hash索引。<br>1). 结构<br>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br><img src="/images/hash%E8%A1%A8.jpg" alt="hash表"><br>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。<br><img src="/images/hash%E5%86%B2%E7%AA%81.jpg" alt="hash冲突"><br>2). 特点<br>A. Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，…）<br>B. 无法利用索引完成排序操作<br>C. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引<br>3). 存储引擎支持<br>在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。<br>思考题： 为什么InnoDB存储引擎选择使用B+tree索引结构?<br>A. 相对于二叉树，层级更少，搜索效率高；<br>B. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；<br>C. 相对Hash索引，B+tree支持范围匹配及排序操作；</p>
<h2 id="2-3-索引分类"><a href="#2-3-索引分类" class="headerlink" title="2.3 索引分类"></a>2.3 索引分类</h2><h3 id="2-3-1-索引分类"><a href="#2-3-1-索引分类" class="headerlink" title="2.3.1 索引分类"></a>2.3.1 索引分类</h3><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建, 只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<h3 id="2-3-2-聚集索引-amp-二级索引"><a href="#2-3-2-聚集索引-amp-二级索引" class="headerlink" title="2.3.2 聚集索引&amp;二级索引"></a>2.3.2 聚集索引&amp;二级索引</h3><p>而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引(Clustered Index)</td>
<td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td>必须有,而且只有一个</td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<p>聚集索引选取规则:</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引。</li>
<li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li>
</ul>
<p>聚集索引和二级索引的具体结构如下：<br><img src="/images/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.jpg" alt="聚集索引"></p>
<ul>
<li>聚集索引的叶子节点下挂的是这一行的数据 。</li>
<li>二级索引的叶子节点下挂的是该字段值对应的主键值。<br>接下来，我们来分析一下，当我们执行如下的SQL语句时，具体的查找过程是什么样子的。<br><img src="/images/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.jpg" alt="二级索引"><br>具体过程如下:<br>①. 由于是根据name字段进行查询，所以先根据name=’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。<br>②. 由于查询返回的数据是 ，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。<br>③. 最终拿到这一行的数据，直接返回即可。<br>回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。<br>思考题：</li>
<li>以下两条SQL语句，那个执行效率高? 为什么?<ul>
<li>A. select * from user where id = 10 ;</li>
<li>B. select * from user where name = ‘Arm’ ;</li>
</ul>
</li>
<li>备注: id为主键，name字段创建的有索引；</li>
</ul>
<p>解答：</p>
<ul>
<li>A 语句的执行性能要高于B 语句。<ul>
<li>因为A语句直接走聚集索引，直接返回数据。 而B语句需要先查询name字段的二级索引，然后再查询聚集索引，也就是需要进行回表查询。<br>思考题：<br>InnoDB主键索引的B+tree高度为多高呢?<br><img src="/images/%E4%BC%98%E5%8C%96.jpg" alt="优化"><br>假设:</li>
</ul>
</li>
<li>一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。<br>高度为2：</li>
<li>n * 8 + (n + 1) * 6 = 16 * 1024 , 算出n约为 1170</li>
<li>1171 * 16 = 18736</li>
<li>也就是说，如果树的高度为2，则可以存储 18000 多条记录。<br>高度为3：</li>
<li>1171 * 1171 * 16 = 21939856</li>
<li>也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。</li>
</ul>
<h2 id="2-4-索引语法"><a href="#2-4-索引语法" class="headerlink" title="2.4 索引语法"></a>2.4 索引语法</h2><p>1). 创建索引</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">CREATE <span class="token punctuation">[</span> UNIQUE <span class="token operator">|</span> FULLTEXT <span class="token punctuation">]</span> INDEX index_name <span class="token class-name">ON</span> table_name <span class="token punctuation">(</span>index_col_name<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>2). 查看索引</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">SHOW INDEX <span class="token class-name">FROM</span> table_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>3). 删除索引</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">DROP INDEX index_name <span class="token class-name">ON</span> table_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2-5-SQL性能分析"><a href="#2-5-SQL性能分析" class="headerlink" title="2.5 SQL性能分析"></a>2.5 SQL性能分析</h2><h3 id="2-5-1-SQL执行频率"><a href="#2-5-1-SQL执行频率" class="headerlink" title="2.5.1 SQL执行频率"></a>2.5.1 SQL执行频率</h3><p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span> session 是查看当前会话 <span class="token punctuation">;</span>
<span class="token operator">--</span> global 是查询全局数据 <span class="token punctuation">;</span>
SHOW GLOBAL STATUS LIKE '<span class="token class-name">Com_______</span>'<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Com_delete: 删除次数<br>Com_insert: 插入次数<br>Com_select: 查询次数<br>Com_update: 更新次数<br>我们可以在当前数据库再执行几次查询操作，然后再次查看执行频次，看看 Com_select 参数会不会变化。<br>通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</p>
<p>那么通过查询SQL的执行频次，我们就能够知道当前数据库到底是增删改为主，还是查询为主。 那假如说是以查询为主，我们又该如何定位针对于那些查询语句进行优化呢？ 次数我们可以借助于慢查询日志。</p>
<p>接下来，我们就来介绍一下MySQL中的慢查询日志。</p>
<h3 id="2-5-2-慢查询日志"><a href="#2-5-2-慢查询日志" class="headerlink" title="2.5.2 慢查询日志"></a>2.5.2 慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p>
<p>MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。</p>
<p>如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"># 开启<span class="token class-name">MySQL</span>慢日志查询开关
slow_query_log<span class="token operator">=</span><span class="token number">1</span>
# 设置慢日志的时间为<span class="token number">2</span>秒，SQL语句执行时间超过<span class="token number">2</span>秒，就会视为慢查询，记录慢查询日志
long_query_time<span class="token operator">=</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息/var/lib/mysql/localhost-slow.log。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">systemctl restart mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后，再次查看开关情况，慢查询日志就已经打开了。</p>
<h3 id="2-5-3-profile详情"><a href="#2-5-3-profile详情" class="headerlink" title="2.5.3 profile详情"></a>2.5.3 profile详情</h3><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">SELECT @<span class="token annotation punctuation">@have_profiling</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在session/global级别开启profiling：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SET</span> profiling <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>开关已经打开了，接下来，我们所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去了。 我们直接执行如下的SQL语句：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from tb_user<span class="token punctuation">;</span>
select <span class="token operator">*</span> from tb_user where id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
select <span class="token operator">*</span> from tb_user where name <span class="token operator">=</span> <span class="token char">'白起'</span><span class="token punctuation">;</span>
select <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> from tb_sku<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span> 查看每一条SQL的耗时基本情况
show profiles<span class="token punctuation">;</span>
<span class="token operator">--</span> 查看指定query_id的SQL语句各个阶段的耗时情况
show profile <span class="token keyword">for</span> query query_id<span class="token punctuation">;</span>
<span class="token operator">--</span> 查看指定query_id的SQL语句CPU的使用情况
show profile cpu <span class="token keyword">for</span> query query_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-5-4-explain"><a href="#2-5-4-explain" class="headerlink" title="2.5.4 explain"></a>2.5.4 explain</h3><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span> 直接在select语句之前加上关键字 explain <span class="token operator">/</span> desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Explain 执行计划中各个字段的含义:</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等</td>
</tr>
<tr>
<td>type</td>
<td>表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。</td>
</tr>
<tr>
<td>possible_key</td>
<td>显示可能应用在这张表上的索引，一个或多个。</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引，如果为NULL，则没有使用索引。</td>
</tr>
<tr>
<td>key_len</td>
<td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</td>
</tr>
<tr>
<td>rows</td>
<td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</td>
</tr>
<tr>
<td>filtered</td>
<td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td>
</tr>
</tbody></table>
<h2 id="2-6-索引使用"><a href="#2-6-索引使用" class="headerlink" title="2.6 索引使用"></a>2.6 索引使用</h2><h3 id="2-6-1-验证索引效率"><a href="#2-6-1-验证索引效率" class="headerlink" title="2.6.1 验证索引效率"></a>2.6.1 验证索引效率</h3><p>在讲解索引的使用原则之前，先通过一个简单的案例，来验证一下索引，看看是否能够通过索引来提升数据查询性能。在演示的时候，我们还是使用之前准备的一张表 tb_sku , 在这张表中准备了1000w的记录。<br>这张表中id为主键，有主键索引，而其他字段是没有建立索引的。 我们先来查询其中的一条记录，看看里面的字段情况，执行如下SQL：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from tb_sku where id <span class="token operator">=</span> <span class="token number">1</span>\<span class="token class-name">G</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以看到即使有1000w的数据,根据id进行数据查询,性能依然很快，因为主键id是有索引的。 那么接下来，我们再来根据 sn 字段进行查询，执行如下SQL：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">SELECT <span class="token operator">*</span> FROM tb_sku <span class="token class-name">WHERE</span> sn <span class="token operator">=</span> '<span class="token number">100000003145001</span>'<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们可以看到根据sn字段进行查询，查询返回了一条数据，结果耗时 20.78sec，就是因为sn没有索引，而造成查询效率很低。<br>那么我们可以针对于sn字段，建立一个索引，建立了索引之后，我们再次根据sn进行查询，再来看一下查询耗时情况。<br>创建索引：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">create index idx_sku_sn on <span class="token function">tb_sku</span><span class="token punctuation">(</span>sn<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后再次执行相同的SQL语句，再次查看SQL的耗时。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">SELECT <span class="token operator">*</span> FROM tb_sku <span class="token class-name">WHERE</span> sn <span class="token operator">=</span> '<span class="token number">100000003145001</span>'<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们明显会看到，sn字段建立了索引之后，查询性能大大提升。建立索引前后，查询耗时都不是一个数量级的。</p>
<h3 id="2-6-2-最左前缀法则"><a href="#2-6-2-最左前缀法则" class="headerlink" title="2.6.2 最左前缀法则"></a>2.6.2 最左前缀法则</h3><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。<br>以 tb_user 表为例，我们先来查看一下之前 tb_user 表所创建的索引。<br>在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession，age，status。</p>
<p>对于最左前缀法则指的是，查询时，最左变的列，也就是profession必须存在，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效。 接下来，我们来演示几组案例，看一下具体的执行计划：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span> and age <span class="token operator">=</span> <span class="token number">31</span> and status <span class="token operator">=</span> <span class="token char">'0'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span> and age <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>以上的这三组测试中，我们发现只要联合索引最左边的字段 profession存在，索引就会生效，只不过索引的长度不同。 而且由以上三组测试，我们也可以推测出profession字段索引长度为47、age字段索引长度为2、status字段索引长度为5。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where age <span class="token operator">=</span> <span class="token number">31</span> and status <span class="token operator">=</span> <span class="token char">'0'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where status <span class="token operator">=</span> <span class="token char">'0'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>而通过上面的这两组测试，我们也可以看到索引并未生效，原因是因为不满足最左前缀法则，联合索引最左边的列profession不存在。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span> and status <span class="token operator">=</span> <span class="token char">'0'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上述的SQL查询时，存在profession字段，最左边的列是存在的，索引满足最左前缀法则的基本条件。但是查询时，跳过了age这个列，所以后面的列索引是不会使用的，也就是索引部分生效，所以索引的长度就是47。<br>思考题：当执行SQL语句: explain select * from tb_user where age = 31 andstatus = ‘0’ and profession = ‘软件工程’； 时，是否满足最左前缀法则，走不走上述的联合索引，索引长度？<br>可以看到，是完全满足最左前缀法则的，索引长度54，联合索引是生效的。<br>注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p>
<h3 id="2-6-3-范围查询"><a href="#2-6-3-范围查询" class="headerlink" title="2.6.3 范围查询"></a>2.6.3 范围查询</h3><p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span> and age <span class="token operator">&gt;</span> <span class="token number">30</span> and status <span class="token operator">=</span> <span class="token char">'0'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当范围查询使用&gt; 或 &lt; 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字段是没有走索引的。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span> and age <span class="token operator">&gt;=</span> <span class="token number">30</span> and status <span class="token operator">=</span> <span class="token char">'0'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当范围查询使用&gt;= 或 &lt;= 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引的。<br>所以，在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt;。</p>
<h3 id="2-6-4-索引失效情况"><a href="#2-6-4-索引失效情况" class="headerlink" title="2.6.4 索引失效情况"></a>2.6.4 索引失效情况</h3><h4 id="2-6-4-1-索引列运算"><a href="#2-6-4-1-索引列运算" class="headerlink" title="2.6.4.1 索引列运算"></a>2.6.4.1 索引列运算</h4><p>不要在索引列上进行运算操作， 索引将失效。<br>在tb_user表中，除了前面介绍的联合索引之外，还有一个索引，是phone字段的单列索引。<br>A. 当根据phone字段进行等值匹配查询时, 索引生效。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where phone <span class="token operator">=</span> '<span class="token number">17799990015</span>'<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>B. 当根据phone字段进行函数运算操作之后，索引失效。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where <span class="token function">substring</span><span class="token punctuation">(</span>phone<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token char">'15'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="2-6-4-2-字符串不加引号"><a href="#2-6-4-2-字符串不加引号" class="headerlink" title="2.6.4.2 字符串不加引号"></a>2.6.4.2 字符串不加引号</h4><p>字符串类型字段使用时，不加引号，索引将失效。<br>接下来，我们通过两组示例，来看看对于字符串类型的字段，加单引号与不加单引号的区别：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span> and age <span class="token operator">=</span> <span class="token number">31</span> and status <span class="token operator">=</span> <span class="token char">'0'</span><span class="token punctuation">;</span>
explain select <span class="token operator">*</span> from tb_user where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span> and age <span class="token operator">=</span> <span class="token number">31</span> and status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where phone <span class="token operator">=</span> '<span class="token number">17799990015</span>'<span class="token punctuation">;</span>
explain select <span class="token operator">*</span> from tb_user where phone <span class="token operator">=</span> <span class="token number">17799990015</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>经过上面两组示例，我们会明显的发现，如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。</p>
<h4 id="2-6-4-3-模糊查询"><a href="#2-6-4-3-模糊查询" class="headerlink" title="2.6.4.3 模糊查询"></a>2.6.4.3 模糊查询</h4><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。<br>接下来，我们来看一下这三条SQL语句的执行效果，查看一下其执行计划：<br>由于下面查询语句中，都是根据profession字段查询，符合最左前缀法则，联合索引是可以生效的，我们主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where profession like <span class="token char">'软件%'</span><span class="token punctuation">;</span>
explain select <span class="token operator">*</span> from tb_user where profession like <span class="token char">'%工程'</span><span class="token punctuation">;</span>
explain select <span class="token operator">*</span> from tb_user where profession like <span class="token char">'%工%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>经过上述的测试，我们发现，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字前面加了%，索引将会失效。</p>
<h4 id="3-6-4-4-or连接条件"><a href="#3-6-4-4-or连接条件" class="headerlink" title="3.6.4.4 or连接条件"></a>3.6.4.4 or连接条件</h4><p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where id <span class="token operator">=</span> <span class="token number">10</span> or age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>
explain select <span class="token operator">*</span> from tb_user where phone <span class="token operator">=</span> '<span class="token number">17799990017</span>' or age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。<br>然后，我们可以对age字段建立索引。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">create index idx_user_age on <span class="token function">tb_user</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>建立了索引之后，我们再次执行上述的SQL语句，看看前后执行计划的变化。<br>最终，我们发现，当or连接的条件，左右两侧字段都有索引时，索引才会生效。</p>
<h4 id="3-6-4-5-数据分布影响"><a href="#3-6-4-5-数据分布影响" class="headerlink" title="3.6.4.5 数据分布影响"></a>3.6.4.5 数据分布影响</h4><p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from tb_user where phone <span class="token operator">&gt;=</span> '<span class="token number">17799990005</span>'<span class="token punctuation">;</span>
select <span class="token operator">*</span> from tb_user where phone <span class="token operator">&gt;=</span> '<span class="token number">17799990015</span>'<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>经过测试我们发现，相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样，这是为什么呢？<br>就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</p>
<p>接下来，我们再来看看 is null 与 is not null 操作是否走索引。<br>执行如下两条语句 ：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user where profession is <span class="token keyword">null</span><span class="token punctuation">;</span>
explain select <span class="token operator">*</span> from tb_user where profession is not <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接下来，我们做一个操作将profession字段值全部更新为null。<br>然后，再次执行上述的两条SQL，查看SQL语句的执行计划。<br>最终我们看到，一模一样的SQL语句，先后执行了两次，结果查询计划是不一样的，为什么会出现这种现象，这是和数据库的数据分布有关系。查询时MySQL会评估，走索引快，还是全表扫描快，如果全表扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null是否走索引，得具体情况具体分析，并不是固定的。</p>
<h3 id="2-6-5-SQL提示"><a href="#2-6-5-SQL提示" class="headerlink" title="2.6.5 SQL提示"></a>2.6.5 SQL提示</h3><p>把上述的 idx_user_age, idx_email 这两个之前测试使用过的索引直接删除。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">drop index idx_user_age on tb_user<span class="token punctuation">;</span>
drop index idx_email on tb_user<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>A. 执行SQL : explain select * from tb_user where profession = ‘软件工程’;<br>查询走了联合索引。<br>B. 执行SQL，创建profession的单列索引：create index idx_user_pro on tb_user(profession);<br>C. 创建单列索引后，再次执行A中的SQL语句，查看执行计划，看看到底走哪个索引。<br>测试结果，我们可以看到，possible_keys中 idx_user_pro_age_sta,idx_user_pro 这两个索引都可能用到，最终MySQL选择了idx_user_pro_age_sta索引。这是MySQL自动选择的结果。<br>那么，我们能不能在查询的时候，自己来指定使用哪个索引呢？ 答案是肯定的，此时就可以借助于MySQL的SQL提示来完成。 接下来，介绍一下SQL提示。<br>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。<br>1). use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user use <span class="token function">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>2). ignore index ： 忽略指定的索引。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user ignore <span class="token function">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>3). force index ： 强制使用索引。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_user force <span class="token function">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="2-6-6-覆盖索引"><a href="#2-6-6-覆盖索引" class="headerlink" title="2.6.6 覆盖索引"></a>2.6.6 覆盖索引</h3><p>尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。<br>接下来，我们来看一组SQL的执行计划，看看执行计划的差别，然后再来具体做一个解析。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select id<span class="token punctuation">,</span> profession from tb_user where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span> and age <span class="token operator">=</span> <span class="token number">31</span> and status <span class="token operator">=</span> <span class="token char">'0'</span> <span class="token punctuation">;</span>
explain select id<span class="token punctuation">,</span>profession<span class="token punctuation">,</span>age<span class="token punctuation">,</span> status from tb_user where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span> and age <span class="token operator">=</span> <span class="token number">31</span> and status <span class="token operator">=</span> <span class="token char">'0'</span> <span class="token punctuation">;</span>
explain select id<span class="token punctuation">,</span>profession<span class="token punctuation">,</span>age<span class="token punctuation">,</span> status<span class="token punctuation">,</span> name from tb_user where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span> and age <span class="token operator">=</span> <span class="token number">31</span> and status <span class="token operator">=</span> <span class="token char">'0'</span> <span class="token punctuation">;</span>
explain select <span class="token operator">*</span> from tb_user where profession <span class="token operator">=</span> <span class="token char">'软件工程'</span> and age <span class="token operator">=</span> <span class="token number">31</span> and status <span class="token operator">=</span> <span class="token char">'0'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述这几条SQL的执行结果为:<br><img src="/images/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.jpg" alt="覆盖索引"><br>从上述的执行计划我们可以看到，这四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差异。但是此时，我们主要关注的是后面的Extra，前面两天SQL的结果为 Using where; UsingIndex ; 而后面两条SQL的结果为: Using index condition 。</p>
<table>
<thead>
<tr>
<th>Extra</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Using where; Using Index</td>
<td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</td>
</tr>
<tr>
<td>Using index condition</td>
<td>查找使用了索引，但是需要回表查询数据</td>
</tr>
</tbody></table>
<p>因为，在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。 而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。</p>
<p>为了大家更清楚的理解，什么是覆盖索引，什么是回表查询，我们一起再来看下面的这组SQL的执行过程。<br>A. 表结构及索引示意图:<br><img src="/images/%E8%A1%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="表结构及索引示意图"><br>id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。<br>B. 执行SQL : select * from tb_user where id = 2;<br><img src="/images/%E8%A1%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE1.jpg" alt="表结构及索引示意图1"><br>根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。<br>C. 执行SQL：selet id,name from tb_user where name = ‘Arm’;<br><img src="/images/%E8%A1%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE2.jpg" alt="表结构及索引示意图2"><br>虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。<br>D. 执行SQL：selet id,name,gender from tb_user where name = ‘Arm’;<br><img src="/images/%E8%A1%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE3.jpg" alt="表结构及索引示意图3"><br>由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点。<br>思考题：一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对以下SQL语句进行优化, 该如何进行才是最优方案:<br>select id,username,password from tb_user where username =’itcast’;<br>答案: 针对于 username, password建立联合索引, sql为: create index idx_user_name_pass on tb_user(username,password);<br>这样可以避免上述的SQL语句，在查询的过程中，出现回表查询。</p>
<h3 id="2-6-7-前缀索引"><a href="#2-6-7-前缀索引" class="headerlink" title="2.6.7 前缀索引"></a>2.6.7 前缀索引</h3><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。<br>1). 语法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">create index idx_xxxx on <span class="token function">table_name</span><span class="token punctuation">(</span><span class="token function">column</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>示例:<br>为tb_user表的email字段，建立长度为5的前缀索引。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">create index idx_email_5 on <span class="token function">tb_user</span><span class="token punctuation">(</span><span class="token function">email</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>2). 前缀长度<br>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token function">count</span><span class="token punctuation">(</span>distinct email<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> from tb_user <span class="token punctuation">;</span>
select <span class="token function">count</span><span class="token punctuation">(</span>distinct <span class="token function">substring</span><span class="token punctuation">(</span>email<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> from tb_user <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3). 前缀索引的查询流程<br><img src="/images/%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.jpg" alt="前缀索引的查询流程"></p>
<h3 id="2-6-8-单列索引与联合索引"><a href="#2-6-8-单列索引与联合索引" class="headerlink" title="2.6.8 单列索引与联合索引"></a>2.6.8 单列索引与联合索引</h3><p>单列索引：即一个索引只包含单个列。<br>联合索引：即一个索引包含了多个列。</p>
<p>我们先来看看 tb_user 表中目前的索引情况:<br>在查询出来的索引中，既有单列索引，又有联合索引。<br>接下来，我们来执行一条SQL语句，看看其执行计划：<br>通过上述执行计划我们可以看出来，在and连接的两个字段 phone、name上都是有单列索引的，但是最终mysql只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的。<br>紧接着，我们再来创建一个phone和name字段的联合索引来查询一下执行计划。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">create unique index idx_user_phone_name on <span class="token function">tb_user</span><span class="token punctuation">(</span>phone<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此时，查询时，就走了联合索引，而在联合索引中包含 phone、name的信息，在叶子节点下挂的是对应的主键id，所以查询是无需回表查询的。<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>
<p>如果查询使用的是联合索引，具体的结构示意图如下：<br><img src="/images/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.jpg" alt="联合索引"></p>
<h2 id="2-7-索引设计原则"><a href="#2-7-索引设计原则" class="headerlink" title="2.7 索引设计原则"></a>2.7 索引设计原则</h2><p>1). 针对于数据量较大，且查询比较频繁的表建立索引。<br>2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。<br>3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。<br>4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。<br>5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。<br>6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。<br>7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p>
<h1 id="3-SQL优化"><a href="#3-SQL优化" class="headerlink" title="3. SQL优化"></a>3. SQL优化</h1><h2 id="3-1-插入数据"><a href="#3-1-插入数据" class="headerlink" title="3.1 插入数据"></a>3.1 插入数据</h2><h3 id="3-1-1-insert"><a href="#3-1-1-insert" class="headerlink" title="3.1.1 insert"></a>3.1.1 insert</h3><p>如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">insert into tb_test <span class="token function">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char">'tom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
insert into tb_test <span class="token function">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token char">'cat'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
insert into tb_test <span class="token function">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token char">'jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>1). 优化方案一<br>批量插入数据</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Insert</span> into tb_test <span class="token function">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token char">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token char">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>2). 优化方案二<br>手动控制事务</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">start transaction<span class="token punctuation">;</span>
insert into tb_test <span class="token function">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token char">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token char">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
insert into tb_test <span class="token function">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token char">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token char">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token char">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
insert into tb_test <span class="token function">values</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token char">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token char">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token char">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
commit<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3). 优化方案三<br>主键顺序插入，性能要高于乱序插入。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">主键乱序插入 <span class="token operator">:</span> <span class="token number">8</span> <span class="token number">1</span> <span class="token number">9</span> <span class="token number">21</span> <span class="token number">88</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">15</span> <span class="token number">89</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">3</span>
主键顺序插入 <span class="token operator">:</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">15</span> <span class="token number">21</span> <span class="token number">88</span> <span class="token number">89</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="3-1-2-大批量插入数据"><a href="#3-1-2-大批量插入数据" class="headerlink" title="3.1.2 大批量插入数据"></a>3.1.2 大批量插入数据</h3><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。操作如下：<br>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p>
<pre class="line-numbers language-java--" data-language="java--"><div class="caption"><span>客户端连接服务端时，加上参数 -–local-infile</span></div><code class="language-java--">mysql –-local-infile -u root -p
-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile = 1;
-- 执行load指令将准备好的数据，加载到表结构中
load data local infile '/root/sql1.log' into table tb_user fields
terminated by ',' lines terminated by '\n' ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>主键顺序插入性能高于乱序插入<br>示例演示:<br>A. 创建表结构</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">CREATE TABLE `tb_user` <span class="token punctuation">(</span>
  `id` <span class="token function">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT <span class="token class-name">NULL</span> AUTO_INCREMENT<span class="token punctuation">,</span>
  `username` <span class="token function">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token class-name">NOT</span> NULL<span class="token punctuation">,</span>
  `password` <span class="token function">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token class-name">NOT</span> NULL<span class="token punctuation">,</span>
  `name` <span class="token function">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token class-name">NOT</span> NULL<span class="token punctuation">,</span>
  `birthday` DATE <span class="token class-name">DEFAULT</span> NULL<span class="token punctuation">,</span>
  `sex` <span class="token function">CHAR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token class-name">DEFAULT</span> NULL<span class="token punctuation">,</span>
  <span class="token class-name">PRIMARY</span> KEY <span class="token punctuation">(</span>`id`<span class="token punctuation">)</span><span class="token punctuation">,</span>
  UNIQUE KEY `unique_user_username` <span class="token punctuation">(</span>`username`<span class="token punctuation">)</span>
<span class="token punctuation">)</span> ENGINE<span class="token operator">=</span>INNODB <span class="token class-name">DEFAULT</span> CHARSET<span class="token operator">=</span>utf8 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>B. 设置参数</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span> 客户端连接服务端时，加上参数 <span class="token operator">-</span>–local<span class="token operator">-</span>infile
mysql –<span class="token operator">-</span>local<span class="token operator">-</span>infile <span class="token operator">-</span>u root <span class="token operator">-</span>p
<span class="token operator">--</span> 设置全局参数local_infile为<span class="token number">1</span>，开启从本地加载文件导入数据的开关
set global local_infile <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>C. load加载数据</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">load data local infile '<span class="token operator">/</span>root<span class="token operator">/</span>load_user_100w_sort<span class="token punctuation">.</span>sql' into table tb_userfields terminated by <span class="token char">','</span> lines terminated by <span class="token char">'\n'</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们看到，插入100w的记录，17s就完成了，性能很好。<br>在load时，主键顺序插入性能高于乱序插入</p>
<h2 id="3-2-主键优化"><a href="#3-2-主键优化" class="headerlink" title="3.2 主键优化"></a>3.2 主键优化</h2><p>在上一小节，我们提到，主键顺序插入的性能是要高于乱序插入的。 这一小节，就来介绍一下具体的原因，然后再分析一下主键又该如何设计。<br>1). 数据组织方式<br>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。<br><img src="/images/%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96.jpg" alt="主键优化"><br>行数据，都是存储在聚集索引的叶子节点上的。而我们之前也讲解过InnoDB的逻辑结构图：<br><img src="/images/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="逻辑结构图"><br>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接。</p>
<p>2). 页分裂<br>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。<br>A. 主键顺序插入效果<br>①. 从磁盘中申请页， 主键顺序插入<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C1.jpg" alt="主键顺序插入效果1"><br>②. 第一个页没有满，继续往第一页插入<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C2.jpg" alt="主键顺序插入效果2"><br>③. 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C3.jpg" alt="主键顺序插入效果3"><br>④. 当第二页写满了，再往第三页写入<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C4.jpg" alt="主键顺序插入效果4"><br>B. 主键乱序插入效果<br>①. 加入1#,2#页都已经写满了，存放了如图所示的数据<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C4.jpg" alt="主键顺序插入效果5"><br>②. 此时再插入id为50的记录，我们来看看会发生什么现象<br>会再次开启一个页，写入新的页中吗？<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C6.jpg" alt="主键顺序插入效果6"><br>不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C7.jpg" alt="主键顺序插入效果7"><br>但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C8.jpg" alt="主键顺序插入效果8"><br>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C9.jpg" alt="主键顺序插入效果9"><br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C10.jpg" alt="主键顺序插入效果10"><br>移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针。<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C11.jpg" alt="主键顺序插入效果11"><br>上述的这种现象，称之为 “页分裂”，是比较耗费性能的操作。<br>3). 页合并<br>目前表中已有数据的索引结构(叶子节点)如下：<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C12.jpg" alt="主键顺序插入效果12"><br>当我们对已有数据进行删除时，具体的效果如下:<br>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C13.jpg" alt="主键顺序插入效果13"><br>当我们继续删除2#的数据记录<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C14.jpg" alt="主键顺序插入效果14"><br>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C15.jpg" alt="主键顺序插入效果15"><br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C16.jpg" alt="主键顺序插入效果16"><br>删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页<br><img src="/images/%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C17.jpg" alt="主键顺序插入效果17"><br>这个里面所发生的合并页的这个现象，就称之为 “页合并”。<br>知识小贴士：MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p>
<p>4). 索引设计原则<br>满足业务需求的情况下，尽量降低主键的长度。<br>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。<br>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。<br>业务操作时，避免对主键的修改。<br><img src="/images/%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.jpg" alt="索引设计原则"><br><img src="/images/%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%991.jpg" alt="索引设计原则1"></p>
<h2 id="3-3-order-by优化"><a href="#3-3-order-by优化" class="headerlink" title="3.3 order by优化"></a>3.3 order by优化</h2><p>MySQL的排序，有两种方式：<br>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。<br>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。<br>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 Using index。</p>
<p>接下来，我们来做一个测试：<br>A. 数据准备<br>把之前测试时，为tb_user表所建立的部分索引直接删除掉</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">drop index idx_user_phone on tb_user<span class="token punctuation">;</span>
drop index idx_user_phone_name on tb_user<span class="token punctuation">;</span>
drop index idx_user_name on tb_user<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>B. 执行排序SQL</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone from tb_user order by age <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone from tb_user order by age<span class="token punctuation">,</span> phone <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>由于 age, phone 都没有索引，所以此时再排序时，出现Using filesort， 排序性能较低。<br>C. 创建索引</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span> 创建索引
create index idx_user_age_phone_aa on <span class="token function">tb_user</span><span class="token punctuation">(</span>age<span class="token punctuation">,</span>phone<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>D. 创建索引后，根据age, phone进行升序排序</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone from tb_user order by age<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone from tb_user order by age <span class="token punctuation">,</span> phone<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>建立索引之后，再次进行排序查询，就由原来的Using filesort， 变为了 Using index，性能就是比较高的了。<br>E. 创建索引后，根据age, phone进行降序排序</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone from tb_user order by age desc <span class="token punctuation">,</span> phone desc <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也出现 Using index， 但是此时Extra中出现了 Backward index scan，这个代表反向扫描索引，因为在MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan。 在MySQL8版本中，支持降序索引，我们也可以创建降序索引。<br>F. 根据phone，age进行升序排序，phone在前，age在后。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone from tb_user order by phone <span class="token punctuation">,</span> age<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>排序时,也需要满足最左前缀法则,否则也会出现 filesort。因为在创建索引的时候， age是第一个字段，phone是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现<br>F. 根据age, phone进行降序一个升序，一个降序Usingfilesort。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone from tb_user order by age asc <span class="token punctuation">,</span> phone desc <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的，而查询时，一个升序，一个降序，此时就会出现Using filesort。<br>为了解决上述的问题，我们可以创建一个索引，这个联合索引中 age 升序排序，phone 倒序排序。<br>G. 创建联合索引(age 升序排序，phone 倒序排序)</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">create index idx_user_age_phone_ad on <span class="token function">tb_user</span><span class="token punctuation">(</span>age asc <span class="token punctuation">,</span>phone desc<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>H. 然后再次执行如下SQL</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone from tb_user order by age asc <span class="token punctuation">,</span> phone desc <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>升序/降序联合索引结构图示:<br><img src="/images/%E5%8D%87%E9%99%8D%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="升降联合索引结构图"><br><img src="/images/%E5%8D%87%E9%99%8D%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%9B%BE1.jpg" alt="升降联合索引结构图1"><br>由上述的测试,我们得出order by优化原则:<br>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。<br>B. 尽量使用覆盖索引。<br>C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。<br>D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。</p>
<h2 id="3-4-group-by优化"><a href="#3-4-group-by优化" class="headerlink" title="3.4 group by优化"></a>3.4 group by优化</h2><p>分组操作，我们主要来看看索引对于分组操作的影响。<br>首先我们先将 tb_user 表的索引全部删除掉 。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">drop index idx_user_pro_age_sta on tb_user<span class="token punctuation">;</span>
drop index idx_email_5 on tb_user<span class="token punctuation">;</span>
drop index idx_user_age_phone_aa on tb_user<span class="token punctuation">;</span>
drop index idx_user_age_phone_ad on tb_user<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，在没有索引的情况下，执行如下SQL，查询执行计划：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select profession <span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> from tb_user group by profession <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后，我们在针对于 profession ， age， status 创建一个联合索引。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">create index idx_user_pro_age_sta on <span class="token function">tb_user</span><span class="token punctuation">(</span>profession<span class="token punctuation">,</span> age <span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>紧接着，再执行前面相同的SQL查看执行计划。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select profession <span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> from tb_user group by profession <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>再执行如下的分组查询SQL，查看执行计划：<br>我们发现，如果仅仅根据age分组，就会出现 Using temporary ；而如果是 根据profession,age两个字段同时分组，则不会出现 Using temporary。原因是因为对于分组操作，在联合索引中，也是符合最左前缀法则的。</p>
<p>所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能：<br>A. 在分组操作时，可以通过索引来提高效率。</p>
<h2 id="3-5-limit优化"><a href="#3-5-limit优化" class="headerlink" title="3.5 limit优化"></a>3.5 limit优化</h2><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。<br>我们一起来看看执行limit分页查询耗时对比：<br><img src="/images/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E8%80%97%E6%97%B6%E5%AF%B9%E6%AF%94.jpg" alt="分页查询耗时对比"><br>通过测试我们会看到，越往后，分页查询效率越低，这就是分页查询的问题所在。<br>因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p>
<p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">explain select <span class="token operator">*</span> from tb_sku t <span class="token punctuation">,</span> <span class="token punctuation">(</span>select id from tb_sku order by idlimit <span class="token number">2000000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> a where t<span class="token punctuation">.</span>id <span class="token operator">=</span> a<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="3-6-count优化"><a href="#3-6-count优化" class="headerlink" title="3.6 count优化"></a>3.6 count优化</h2><h3 id="3-6-1-概述"><a href="#3-6-1-概述" class="headerlink" title="3.6.1 概述"></a>3.6.1 概述</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> from tb_user <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在之前的测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。</p>
<ul>
<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count( * ) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。</li>
<li>InnoDB 引擎就麻烦了，它执行 count( * ) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。<br>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数据库进行,但是如果是带条件的count又比较麻烦了)。</li>
</ul>
<h3 id="3-6-2-count用法"><a href="#3-6-2-count用法" class="headerlink" title="3.6.2 count用法"></a>3.6.2 count用法</h3><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是NULL，累计值就加 1，否则不加，最后返回累计值。<br>用法：count（ * ）、count（主键）、count（字段）、count（数字）</p>
<table>
<thead>
<tr>
<th>count用法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>count(主键)</td>
<td>InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)</td>
</tr>
<tr>
<td>count(字段)</td>
<td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</td>
</tr>
<tr>
<td>count(数字)</td>
<td>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。</td>
</tr>
<tr>
<td>count(*)</td>
<td>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</td>
</tr>
</tbody></table>
<p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count( * )，所以尽<br>量使用 count( * )。</p>
<h2 id="3-7-update优化"><a href="#3-7-update优化" class="headerlink" title="3.7 update优化"></a>3.7 update优化</h2><p>我们主要需要注意一下update语句执行时的注意事项。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">update course set name <span class="token operator">=</span> <span class="token char">'javaEE'</span> <span class="token number">1</span> where id <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当我们在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放。<br>但是当我们在执行如下SQL时。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">update course set name <span class="token operator">=</span> '<span class="token class-name">SpringBoot</span>' where name <span class="token operator">=</span> <span class="token char">'PHP'</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能大大降低。<br>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</p>
<h1 id="4-视图-x2F-存储过程-x2F-触发器"><a href="#4-视图-x2F-存储过程-x2F-触发器" class="headerlink" title="4. 视图/存储过程/触发器"></a>4. 视图/存储过程/触发器</h1><h2 id="4-1-视图"><a href="#4-1-视图" class="headerlink" title="4.1 视图"></a>4.1 视图</h2><h3 id="4-1-1-介绍"><a href="#4-1-1-介绍" class="headerlink" title="4.1.1 介绍"></a>4.1.1 介绍</h3><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。<br>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p>
<h3 id="4-1-2-语法"><a href="#4-1-2-语法" class="headerlink" title="4.1.2 语法"></a>4.1.2 语法</h3><p>1). 创建</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">CREATE <span class="token punctuation">[</span>OR REPLACE<span class="token punctuation">]</span> VIEW 视图名称<span class="token punctuation">[</span><span class="token punctuation">(</span>列名列表<span class="token punctuation">)</span><span class="token punctuation">]</span> AS SELECT语句 <span class="token punctuation">[</span> WITH <span class="token punctuation">[</span> CASCADED <span class="token operator">|</span> LOCAL <span class="token punctuation">]</span> CHECK OPTION <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>2). 查询</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">查看创建视图语句：SHOW CREATE VIEW 视图名称<span class="token punctuation">;</span>
查看视图数据：SELECT <span class="token operator">*</span> FROM 视图名称 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3). 修改</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">方式一：CREATE <span class="token punctuation">[</span>OR REPLACE<span class="token punctuation">]</span> VIEW 视图名称<span class="token punctuation">[</span><span class="token punctuation">(</span>列名列表<span class="token punctuation">)</span><span class="token punctuation">]</span> AS SELECT语句 <span class="token punctuation">[</span> WITH <span class="token punctuation">[</span> CASCADED <span class="token operator">|</span> LOCAL <span class="token punctuation">]</span> CHECK OPTION <span class="token punctuation">]</span>
方式二：ALTER VIEW 视图名称<span class="token punctuation">[</span><span class="token punctuation">(</span>列名列表<span class="token punctuation">)</span><span class="token punctuation">]</span> AS SELECT语句 <span class="token punctuation">[</span> WITH <span class="token punctuation">[</span> CASCADED <span class="token operator">|</span> LOCAL <span class="token punctuation">]</span> CHECK OPTION <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>4). 删除</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">DROP VIEW <span class="token punctuation">[</span>IF EXISTS<span class="token punctuation">]</span> 视图名称 <span class="token punctuation">[</span><span class="token punctuation">,</span>视图名称<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="4-1-3-检查选项"><a href="#4-1-3-检查选项" class="headerlink" title="4.1.3 检查选项"></a>4.1.3 检查选项</h3><p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。 MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项： CASCADED 和 LOCAL，默认值为 CASCADED 。</p>
<p>1). CASCADED<br>级联。<br>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1视图创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。<br><img src="/images/CASCADED.jpg" alt="CASCADED"><br>2). LOCAL<br>本地。<br>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创建时未指定检查选项。 则在执行检查时，知会检查v2，不会检查v2的关联视图v1。<br><img src="/images/LOCAL.jpg" alt="LOCAL"></p>
<h3 id="4-1-4-视图的更新"><a href="#4-1-4-视图的更新" class="headerlink" title="4.1.4 视图的更新"></a>4.1.4 视图的更新</h3><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：<br>A. 聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）<br>B. DISTINCT<br>C. GROUP BY<br>D. HAVING<br>E. UNION 或者 UNION ALL</p>
<p>示例演示:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">create view stu_v_count as select <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> from student<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上述的视图中，就只有一个单行单列的数据，如果我们对这个视图进行更新或插入的，将会报错。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">insert into stu_v_count <span class="token function">values</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="4-1-5-视图作用"><a href="#4-1-5-视图作用" class="headerlink" title="4.1.5 视图作用"></a>4.1.5 视图作用</h3><p>1). 简单<br>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。<br>2). 安全<br>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</p>
<h2 id="4-2-存储过程"><a href="#4-2-存储过程" class="headerlink" title="4.2 存储过程"></a>4.2 存储过程</h2><h3 id="4-2-1-介绍"><a href="#4-2-1-介绍" class="headerlink" title="4.2.1 介绍"></a>4.2.1 介绍</h3><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。<br><img src="/images/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.jpg" alt="存储过程"><br>特点:</p>
<ul>
<li>封装，复用 ———————–&gt; 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</li>
<li>可以接收参数，也可以返回数据 ——–&gt; 再存储过程中，可以传递参数，也可以接收返回值。</li>
<li>减少网络交互，效率提升 ————-&gt; 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</li>
</ul>
<h3 id="4-2-2-基本语法"><a href="#4-2-2-基本语法" class="headerlink" title="4.2.2 基本语法"></a>4.2.2 基本语法</h3><p>1). 创建</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">CREATE PROCEDURE 存储过程名称 <span class="token punctuation">(</span><span class="token punctuation">[</span> 参数列表 <span class="token punctuation">]</span><span class="token punctuation">)</span>
BEGIN
  <span class="token operator">--</span> SQL语句
END <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>2). 调用</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">CALL 名称 <span class="token punctuation">(</span><span class="token punctuation">[</span> 参数 <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>3). 查看</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">SELECT <span class="token operator">*</span> FROM INFORMATION_SCHEMA<span class="token punctuation">.</span>ROUTINES <span class="token class-name">WHERE</span> ROUTINE_SCHEMA <span class="token operator">=</span> <span class="token char">'xxx'</span><span class="token punctuation">;</span> <span class="token operator">--</span> 查询指
定数据库的存储过程及状态信息
SHOW CREATE PROCEDURE 存储过程名称 <span class="token punctuation">;</span> <span class="token operator">--</span> 查询某个存储过程的定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>4). 删除</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">DROP PROCEDURE <span class="token punctuation">[</span> IF EXISTS <span class="token punctuation">]</span> 存储过程名称 ；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意:在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。</p>
<h3 id="4-2-3-变量"><a href="#4-2-3-变量" class="headerlink" title="4.2.3 变量"></a>4.2.3 变量</h3><p>在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量。</p>
<h3 id="4-2-3-1-系统变量"><a href="#4-2-3-1-系统变量" class="headerlink" title="4.2.3.1 系统变量"></a>4.2.3.1 系统变量</h3><p>系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。<br>1). 查看系统变量</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">SHOW <span class="token punctuation">[</span> SESSION <span class="token operator">|</span> GLOBAL <span class="token punctuation">]</span> VARIABLES <span class="token punctuation">;</span> <span class="token operator">--</span> 查看所有系统变量
SHOW <span class="token punctuation">[</span> SESSION <span class="token operator">|</span> GLOBAL <span class="token punctuation">]</span> VARIABLES LIKE <span class="token char">'......'</span><span class="token punctuation">;</span> <span class="token operator">--</span> 可以通过LIKE模糊匹配方式查找变量
SELECT @@<span class="token punctuation">[</span>SESSION <span class="token operator">|</span> GLOBAL<span class="token punctuation">]</span> 系统变量名<span class="token punctuation">;</span> <span class="token operator">--</span> 查看指定变量的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>2). 设置系统变量</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">SET <span class="token punctuation">[</span> SESSION <span class="token operator">|</span> GLOBAL <span class="token punctuation">]</span> 系统变量名 <span class="token operator">=</span> 值 <span class="token punctuation">;</span>
SET @@<span class="token punctuation">[</span>SESSION <span class="token operator">|</span> GLOBAL<span class="token punctuation">]</span>系统变量名 <span class="token operator">=</span> 值 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注意:如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量。<br>mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置。<br>A. 全局变量(GLOBAL): 全局变量针对于所有的会话。<br>B. 会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</p>
<h4 id="4-2-3-2-用户定义变量"><a href="#4-2-3-2-用户定义变量" class="headerlink" title="4.2.3.2 用户定义变量"></a>4.2.3.2 用户定义变量</h4><p>用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 “@变量名” 使用就可以。其作用域为当前连接。<br>1). 赋值<br>方式一:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">SET <span class="token annotation punctuation">@var_name</span> <span class="token operator">=</span> expr <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token annotation punctuation">@var_name</span> <span class="token operator">=</span> expr<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span>
SET <span class="token annotation punctuation">@var_name</span> <span class="token operator">:</span><span class="token operator">=</span> expr <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token annotation punctuation">@var_name</span> <span class="token operator">:</span><span class="token operator">=</span> expr<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>赋值时，可以使用 = ，也可以使用 := 。<br>方式二:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">SELECT <span class="token annotation punctuation">@var_name</span> <span class="token operator">:</span><span class="token operator">=</span> expr <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token annotation punctuation">@var_name</span> <span class="token operator">:</span><span class="token operator">=</span> expr<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span>
SELECT 字段名 INTO <span class="token annotation punctuation">@var_name</span> FROM 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>2). 使用</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">SELECT <span class="token annotation punctuation">@var_name</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意: 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p>
<h4 id="4-2-3-3-局部变量"><a href="#4-2-3-3-局部变量" class="headerlink" title="4.2.3.3 局部变量"></a>4.2.3.3 局部变量</h4><p>局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN … END块。<br>1). 声明</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">DECLARE 变量名 变量类型 <span class="token punctuation">[</span>DEFAULT <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。<br>2). 赋值</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">SET 变量名 <span class="token operator">=</span> 值 <span class="token punctuation">;</span>
SET 变量名 <span class="token operator">:</span><span class="token operator">=</span> 值 <span class="token punctuation">;</span>
SELECT 字段名 INTO 变量名 FROM 表名 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="4-2-4-if"><a href="#4-2-4-if" class="headerlink" title="4.2.4 if"></a>4.2.4 if</h3><p>1). 介绍<br>if 用于做条件判断，具体的语法结构为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">IF 条件<span class="token number">1</span> THEN
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ELSEIF 条件<span class="token number">2</span> THEN <span class="token operator">--</span> 可选
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ELSE <span class="token operator">--</span> 可选
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token class-name">END</span> IF<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有。</p>
<h3 id="4-2-5-参数"><a href="#4-2-5-参数" class="headerlink" title="4.2.5 参数"></a>4.2.5 参数</h3><p>1). 介绍<br>参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>该类参数作为输入，也就是需要调用时传入值</td>
<td>默认</td>
</tr>
<tr>
<td>OUT</td>
<td>该类参数作为输出，也就是该参数可以作为返回值</td>
<td></td>
</tr>
<tr>
<td>INOUT</td>
<td>既可以作为输入参数，也可以作为输出参数</td>
<td></td>
</tr>
</tbody></table>
<p>用法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">CREATE PROCEDURE 存储过程名称 <span class="token punctuation">(</span><span class="token punctuation">[</span> IN<span class="token operator">/</span>OUT<span class="token operator">/</span>INOUT 参数名 参数类型 <span class="token punctuation">]</span><span class="token punctuation">)</span>
BEGIN
<span class="token operator">--</span> SQL语句
END <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-2-6-case"><a href="#4-2-6-case" class="headerlink" title="4.2.6 case"></a>4.2.6 case</h3><p>1). 介绍<br>case结构及作用，和我们在基础篇中所讲解的流程控制函数很类似。有两种语法格式：<br>语法1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span> 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，执行statement_list2， 否则就执行 statement_list
CASE case_value
  WHEN when_value1 THEN statement_list1
  <span class="token punctuation">[</span> WHEN when_value2 THEN statement_list2<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">[</span> ELSE statement_list <span class="token punctuation">]</span>
<span class="token class-name">END</span> CASE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>语法2：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span> 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_list
CASE
  WHEN search_condition1 THEN statement_list1
  <span class="token punctuation">[</span>WHEN search_condition2 THEN statement_list2<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">[</span>ELSE statement_list<span class="token punctuation">]</span>
<span class="token class-name">END</span> CASE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-2-7-while"><a href="#4-2-7-while" class="headerlink" title="4.2.7 while"></a>4.2.7 while</h3><p>1). 介绍<br>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span> 先判定条件，如果条件为<span class="token boolean">true</span>，则执行逻辑，否则，不执行逻辑
WHILE 条件 DO
  SQL逻辑<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token class-name">END</span> WHILE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-2-8-repeat"><a href="#4-2-8-repeat" class="headerlink" title="4.2.8 repeat"></a>4.2.8 repeat</h3><p>1). 介绍<br>repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span> 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环
REPEAT
  SQL逻辑<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  UNTIL 条件
<span class="token class-name">END</span> REPEAT<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-2-9-loop"><a href="#4-2-9-loop" class="headerlink" title="4.2.9 loop"></a>4.2.9 loop</h3><p>1). 介绍<br>LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。<br>LOOP可以配合一下两个语句使用：</p>
<ul>
<li>LEAVE ：配合循环使用，退出循环。</li>
<li>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">[</span>begin_label<span class="token operator">:</span><span class="token punctuation">]</span> LOOP
  SQL逻辑<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
END LOOP <span class="token punctuation">[</span>end_label<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">LEAVE</span> label<span class="token punctuation">;</span> <span class="token operator">--</span> 退出指定标记的循环体
<span class="token class-name">ITERATE</span> label<span class="token punctuation">;</span> <span class="token operator">--</span> 直接进入下一次循环<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
上述语法中出现的 begin_label，end_label，label 指的都是我们所自定义的标记。</li>
</ul>
<h3 id="4-2-10-游标"><a href="#4-2-10-游标" class="headerlink" title="4.2.10 游标"></a>4.2.10 游标</h3><p>1). 介绍<br>游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。<br>A. 声明游标</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">DECLARE 游标名称 CURSOR FOR 查询语句 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>B. 打开游标</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">OPEN 游标名称 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>C. 获取游标记录</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">FETCH 游标名称 INTO 变量 <span class="token punctuation">[</span><span class="token punctuation">,</span> 变量 <span class="token punctuation">]</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>D. 关闭游标</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">CLOSE 游标名称 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="4-2-11-条件处理程序"><a href="#4-2-11-条件处理程序" class="headerlink" title="4.2.11 条件处理程序"></a>4.2.11 条件处理程序</h3><p>1). 介绍<br>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">DECLARE handler_action HANDLER FOR condition_value <span class="token punctuation">[</span><span class="token punctuation">,</span> condition_value<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> statement <span class="token punctuation">;</span>
handler_action 的取值：
  CONTINUE<span class="token operator">:</span> 继续执行当前程序
  EXIT<span class="token operator">:</span> 终止执行当前程序
condition_value 的取值：
  SQLSTATE sqlstate_value<span class="token operator">:</span> 状态码，如 <span class="token number">02000</span>
  SQLWARNING<span class="token operator">:</span> 所有以<span class="token number">01</span>开头的SQLSTATE代码的简写
  NOT FOUND<span class="token operator">:</span> 所有以<span class="token number">02</span>开头的SQLSTATE代码的简写
  SQLEXCEPTION<span class="token operator">:</span> 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="4-3-存储函数"><a href="#4-3-存储函数" class="headerlink" title="4.3 存储函数"></a>4.3 存储函数</h2><p>1). 介绍<br>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">CREATE FUNCTION 存储函数名称 <span class="token punctuation">(</span><span class="token punctuation">[</span> 参数列表 <span class="token punctuation">]</span><span class="token punctuation">)</span>
RETURNS type <span class="token punctuation">[</span>characteristic <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
BEGIN
  <span class="token operator">--</span> SQL语句
  RETURN <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
END <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>characteristic说明：</p>
<ul>
<li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li>
<li>NO SQL ：不包含 SQL 语句。</li>
<li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</li>
</ul>
<h2 id="4-4-触发器"><a href="#4-4-触发器" class="headerlink" title="4.4 触发器"></a>4.4 触发器</h2><h3 id="4-4-1-介绍"><a href="#4-4-1-介绍" class="headerlink" title="4.4.1 介绍"></a>4.4.1 介绍</h3><p>触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性, 日志记录 , 数据校验等操作 。<br>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW 和 OLD</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT 型触发器</td>
<td>NEW 表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>UPDATE 型触发器</td>
<td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>DELETE 型触发器</td>
<td>OLD 表示将要或者已经删除的数据</td>
</tr>
</tbody></table>
<p>4.4.2 语法<br>1). 创建</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">CREATE TRIGGER trigger_name
BEFORE<span class="token operator">/</span>AFTER INSERT<span class="token operator">/</span>UPDATE<span class="token operator">/</span>DELETE
ON tbl_name FOR EACH ROW <span class="token operator">--</span> 行级触发器
<span class="token class-name">BEGIN</span>
  trigger_stmt <span class="token punctuation">;</span>
END<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>2). 查看</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SHOW</span> TRIGGERS <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>3). 删除</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">DROP TRIGGER <span class="token punctuation">[</span>schema_name<span class="token punctuation">.</span><span class="token punctuation">]</span>trigger_name <span class="token punctuation">;</span> <span class="token operator">--</span> 如果没有指定 schema_name，默认为当前数据库 。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="5-锁"><a href="#5-锁" class="headerlink" title="5. 锁"></a>5. 锁</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。<br>MySQL中的锁，按照锁的粒度分，分为以下三类：</p>
<ul>
<li>全局锁：锁定数据库中的所有表。</li>
<li>表级锁：每次操作锁住整张表。</li>
<li>行级锁：每次操作锁住对应的行数据。</li>
</ul>
<h2 id="5-2-全局锁"><a href="#5-2-全局锁" class="headerlink" title="5.2 全局锁"></a>5.2 全局锁</h2><h3 id="5-2-1-介绍"><a href="#5-2-1-介绍" class="headerlink" title="5.2.1 介绍"></a>5.2.1 介绍</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。<br>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。<br>为什么全库逻辑备份，就需要加全就锁呢？<br>A. 我们一起先来分析一下不加全局锁，可能存在的问题。<br>假设在数据库中存在这样三张表: tb_stock 库存表，tb_order 订单表，tb_orderlog 订单日志表。<br><img src="/images/%E5%85%A8%E5%B1%80%E9%94%81.jpg" alt="全局锁"></p>
<ul>
<li>在进行数据备份时，先备份了tb_stock库存表。</li>
<li>然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）。</li>
<li>然后再执行备份 tb_order表的逻辑。</li>
<li>业务中执行插入订单日志操作。</li>
<li>最后，又备份了tb_orderlog表。<br>此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一致(有最新操作的订单信息,但是库存数没减)。<br>那如何来规避这种问题呢? 此时就可以借助于MySQL的全局锁来解决。<br>B. 再来分析一下加了全局锁后的情况<br><img src="/images/%E5%85%A8%E5%B1%80%E9%94%81%E5%90%8E%E7%9A%84%E6%83%85%E5%86%B5.jpg" alt="全局锁后的情况"><br>对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。</li>
</ul>
<h3 id="5-2-2-语法"><a href="#5-2-2-语法" class="headerlink" title="5.2.2 语法"></a>5.2.2 语法</h3><p>1). 加全局锁</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">flush tables <span class="token keyword">with</span> <span class="token namespace">read</span> lock <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>2). 数据备份</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">mysqldump <span class="token operator">-</span>uroot –p1234 itcast <span class="token operator">&gt;</span> itcast<span class="token punctuation">.</span>sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>数据备份的相关指令, 在后面MySQL管理章节, 还会详细讲解.<br>3). 释放锁</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">unlock tables <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="5-2-3-特点"><a href="#5-2-3-特点" class="headerlink" title="5.2.3 特点"></a>5.2.3 特点</h3><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p>
<ul>
<li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。<br>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份。<pre class="line-numbers language-java" data-language="java"><code class="language-java">mysqldump <span class="token operator">--</span>single<span class="token operator">-</span>transaction <span class="token operator">-</span>uroot –p123456 itcast <span class="token operator">&gt;</span> itcast<span class="token punctuation">.</span>sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h2 id="5-3-表级锁"><a href="#5-3-表级锁" class="headerlink" title="5.3 表级锁"></a>5.3 表级锁</h2><h3 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="5.3.1 介绍"></a>5.3.1 介绍</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。<br>对于表级锁，主要分为以下三类：</p>
<ul>
<li>表锁</li>
<li>元数据锁（meta data lock，MDL）</li>
<li>意向锁</li>
</ul>
<h3 id="5-3-2-表锁"><a href="#5-3-2-表锁" class="headerlink" title="5.3.2 表锁"></a>5.3.2 表锁</h3><p>对于表锁，分为两类：</p>
<ul>
<li>表共享读锁（read lock）</li>
<li>表独占写锁（write lock）<br>语法：</li>
<li>加锁：lock tables 表名… read/write。</li>
<li>释放锁：unlock tables / 客户端断开连接 。<br>特点:<br>A. 读锁<br><img src="/images/%E8%AF%BB%E9%94%81.jpg" alt="读锁"><br>左侧为客户端一，对指定表加了读锁，不会影响右侧客户端二的读，但是会阻塞右侧客户端的写。<br>B. 写锁<br><img src="/images/%E5%86%99%E9%94%81.jpg" alt="写锁"><br>左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。<br>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</li>
</ul>
<h3 id="5-3-3-元数据锁"><a href="#5-3-3-元数据锁" class="headerlink" title="5.3.3 元数据锁"></a>5.3.3 元数据锁</h3><p>meta data lock , 元数据锁，简写MDL。<br>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。<br>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。<br>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。<br>常见的SQL操作时，所添加的元数据锁：</p>
<table>
<thead>
<tr>
<th>对应SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock tables xxx read / write</td>
<td>SHARED_READ_ONLY / SHARED_NO_READ_WRITE</td>
<td></td>
</tr>
<tr>
<td>select 、select … lock in share mode</td>
<td>SHARED_READ</td>
<td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td>
</tr>
<tr>
<td>insert 、update、delete、select … for update</td>
<td>SHARED_WRITE</td>
<td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td>
</tr>
<tr>
<td>alter table …</td>
<td>EXCLUSIVE</td>
<td>与其他的MDL都互斥</td>
</tr>
</tbody></table>
<h3 id="5-3-4-意向锁"><a href="#5-3-4-意向锁" class="headerlink" title="5.3.4 意向锁"></a>5.3.4 意向锁</h3><p>1). 介绍<br>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。<br>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：<br>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。<br><img src="/images/%E6%84%8F%E5%90%91%E9%94%811.jpg" alt="意向锁1"><br>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低。<br><img src="/images/%E6%84%8F%E5%90%91%E9%94%812.jpg" alt="意向锁2"><br>有了意向锁之后 :<br>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。<br><img src="/images/%E6%84%8F%E5%90%91%E9%94%813.jpg" alt="意向锁3"><br>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。<br><img src="/images/%E6%84%8F%E5%90%91%E9%94%814.jpg" alt="意向锁4"><br>2). 分类</p>
<ul>
<li>意向共享锁(IS): 由语句select … lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</li>
<li>意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。<br>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。<br>可以通过以下SQL，查看意向锁及行锁的加锁情况：<pre class="line-numbers language-java" data-language="java"><code class="language-java">select object_schema<span class="token punctuation">,</span>object_name<span class="token punctuation">,</span>index_name<span class="token punctuation">,</span>lock_type<span class="token punctuation">,</span>lock_mode<span class="token punctuation">,</span>lock_data fromperformance_schema<span class="token punctuation">.</span>data_locks<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h2 id="5-4-行级锁"><a href="#5-4-行级锁" class="headerlink" title="5.4 行级锁"></a>5.4 行级锁</h2><h3 id="5-4-1-介绍"><a href="#5-4-1-介绍" class="headerlink" title="5.4.1 介绍"></a>5.4.1 介绍</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。<br>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：<br><img src="/images/%E8%A1%8C%E7%BA%A7%E9%94%81.jpg" alt="行级锁"></p>
<h3 id="5-4-2-行锁"><a href="#5-4-2-行锁" class="headerlink" title="5.4.2 行锁"></a>5.4.2 行锁</h3><p>1). 介绍<br>InnoDB实现了以下两种类型的行锁：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li>
<li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li>
</ul>
<p>两种行锁的兼容情况如下:<br><img src="/images/%E4%B8%A4%E7%A7%8D%E8%A1%8C%E9%94%81%E7%9A%84%E5%85%BC%E5%AE%B9%E6%83%85%E5%86%B5.jpg" alt="两种行锁的兼容情况"><br>常见的SQL语句，在执行时，所加的行锁如下：</p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>UPDATE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>DELETE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>SELECT（正常）</td>
<td>不加任何锁</td>
<td></td>
</tr>
<tr>
<td>SELECT … LOCK IN SHARE MODE</td>
<td>共享锁</td>
<td>需要手动在SELECT之后加LOCK IN SHARE MODE</td>
</tr>
<tr>
<td>SELECT … FOR UPDATE</td>
<td>排他锁</td>
<td>需要手动在SELECT之后加FOR UPDATE</td>
</tr>
</tbody></table>
<p>2). 演示<br>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p>
<ul>
<li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li>
<li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。<br>可以通过以下SQL，查看意向锁及行锁的加锁情况：<pre class="line-numbers language-java" data-language="java"><code class="language-java">select object_schema<span class="token punctuation">,</span>object_name<span class="token punctuation">,</span>index_name<span class="token punctuation">,</span>lock_type<span class="token punctuation">,</span>lock_mode<span class="token punctuation">,</span>lock_data fromperformance_schema<span class="token punctuation">.</span>data_locks<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h3 id="5-4-3-间隙锁-amp-临键锁"><a href="#5-4-3-间隙锁-amp-临键锁" class="headerlink" title="5.4.3 间隙锁&amp;临键锁"></a>5.4.3 间隙锁&amp;临键锁</h3><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p>
<ul>
<li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li>
<li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。</li>
<li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。<br>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</li>
</ul>
<h1 id="6-InnoDB引擎"><a href="#6-InnoDB引擎" class="headerlink" title="6. InnoDB引擎"></a>6. InnoDB引擎</h1><h2 id="6-1-逻辑存储结构"><a href="#6-1-逻辑存储结构" class="headerlink" title="6.1 逻辑存储结构"></a>6.1 逻辑存储结构</h2><p>InnoDB的逻辑存储结构如下图所示:<br><img src="/images/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%841.jpg" alt="逻辑存储结构1"><br>1). 表空间<br>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。<br>2). 段<br>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。<br>3). 区<br>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。<br>4). 页<br>页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。<br>5). 行<br>行，InnoDB 存储引擎数据是按行进行存放的。<br>在行中，默认有两个隐藏字段：</p>
<ul>
<li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li>
<li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<h2 id="6-2-架构"><a href="#6-2-架构" class="headerlink" title="6.2 架构"></a>6.2 架构</h2><h3 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a>6.2.1 概述</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。<br><img src="/images/%E6%9E%B6%E6%9E%84.jpg" alt="架构"></p>
<h3 id="6-2-2-内存结构"><a href="#6-2-2-内存结构" class="headerlink" title="6.2.2 内存结构"></a>6.2.2 内存结构</h3><p><img src="/images/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpg" alt="内存结构"><br>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 接下来介绍一下这四个部分。</p>
<p>1). Buffer Pool<br>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I/O。<br>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。<br>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。<br>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p>
<ul>
<li>free page：空闲page，未被使用。</li>
<li>clean page：被使用page，数据没有被修改过。</li>
<li>dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。<br>在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置： show variables like ‘innodb_buffer_pool_size’;</li>
</ul>
<p>2). Change Buffer<br>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。Change Buffer的意义是什么呢?<br>先来看一幅图，这个是二级索引的结构图：<br><img src="/images/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="二级索引的结构图"><br>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。<br>3). Adaptive Hash Index<br>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。<br>自适应哈希索引，无需人工干预，是系统根据情况自动完成。<br>参数： adaptive_hash_index<br>4). Log Buffer<br>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。<br>参数:<br>innodb_log_buffer_size：缓冲区大小<br>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：</p>
<ul>
<li>1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</li>
<li>0: 每秒将日志写入并刷新到磁盘一次。</li>
<li>2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</li>
</ul>
<h3 id="6-2-3-磁盘结构"><a href="#6-2-3-磁盘结构" class="headerlink" title="6.2.3 磁盘结构"></a>6.2.3 磁盘结构</h3><p>接下来，再来看看InnoDB体系结构的右边部分，也就是磁盘结构：<br><img src="/images/%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.jpg" alt="磁盘结构"><br>1). System Tablespace<br>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)<br>参数：innodb_data_file_path</p>
<p>2). File-Per-Table Tablespaces<br>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。<br>开关参数：innodb_file_per_table ，该参数默认开启。<br>3). General Tablespaces<br>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p>
<p>A. 创建表空间</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">CREATE TABLESPACE ts_name ADD DATAFILE 'file_name' ENGINE <span class="token operator">=</span> engine_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>B. 创建表时指定表空间</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">CREATE TABLE xxx <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token class-name">TABLESPACE</span> ts_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>4). Undo Tablespaces<br>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。<br>5). Temporary Tablespaces<br>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。<br>6). Doublewrite Buffer Files<br>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。<br>7). Redo Log<br>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。</p>
<p>前面我们介绍了InnoDB的内存结构，以及磁盘结构，那么内存中我们所更新的数据，又是如何到磁盘中的呢？ 此时，就涉及到一组后台线程，接下来，就来介绍一些InnoDB中涉及到的后台线程。<br><img src="/images/%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.jpg" alt="后台线程"></p>
<h3 id="6-2-4-后台线程"><a href="#6-2-4-后台线程" class="headerlink" title="6.2.4 后台线程"></a>6.2.4 后台线程</h3><p><img src="/images/%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B1.jpg" alt="后台线程1"><br>在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、 Page Cleaner Thread。<br>1). Master Thread<br>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 。<br>2). IO Thread<br>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IOThread主要负责这些IO请求的回调。</p>
<table>
<thead>
<tr>
<th>线程类型</th>
<th>默认个数</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td>Read thread</td>
<td>4</td>
<td>负责读操作</td>
</tr>
<tr>
<td>Write thread</td>
<td>4</td>
<td>负责写操作</td>
</tr>
<tr>
<td>Log thread</td>
<td>1</td>
<td>负责将日志缓冲区刷新到磁盘</td>
</tr>
<tr>
<td>Insert buffer thread</td>
<td>1</td>
<td>负责将写缓冲区内容刷新到磁盘</td>
</tr>
</tbody></table>
<p>我们可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">show engine innodb status \<span class="token class-name">G</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>3). Purge Thread<br>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。<br>4). Page Cleaner Thread<br>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p>
<h2 id="6-3-事务原理"><a href="#6-3-事务原理" class="headerlink" title="6.3 事务原理"></a>6.3 事务原理</h2><h3 id="6-3-1-事务基础"><a href="#6-3-1-事务基础" class="headerlink" title="6.3.1 事务基础"></a>6.3.1 事务基础</h3><p>1). 事务<br>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。<br>2). 特性</p>
<ul>
<li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li>
<li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li>
<li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p>那实际上，我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。<br><img src="/images/%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7.jpg" alt="四大特性"><br>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 而持久性是通过数据库的锁，加上MVCC来保证的。<br><img src="/images/%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A71.jpg" alt="四大特性1"><br>我们在讲解事务原理的时候，主要就是来研究一下redolog，undolog以及MVCC。</p>
<h3 id="6-3-2-redo-log"><a href="#6-3-2-redo-log" class="headerlink" title="6.3.2 redo log"></a>6.3.2 redo log</h3><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p>
<p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo logfile）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p>
<p>如果没有redolog，可能会存在什么问题的？ 我们一起来分析一下。</p>
<p>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。<br><img src="/images/InnoDB%E5%BC%95%E6%93%8E.jpg" alt="InnoDB引擎"><br>那么，如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，接下来我们再来分析一下，通过redolog如何解决这个问题。<br><img src="/images/InnoDB%E5%BC%95%E6%93%8E1.jpg" alt="InnoDB引擎1"><br>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redolog buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p>
<p>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ?</p>
<p>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p>
<h3 id="6-3-3-undo-log"><a href="#6-3-3-undo-log" class="headerlink" title="6.3.3 undo log"></a>6.3.3 undo log</h3><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制) 。<br>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undolog中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p>
<p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</p>
<p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment回滚段中，内部包含1024个undo log segment。</p>
<h2 id="6-4-MVCC"><a href="#6-4-MVCC" class="headerlink" title="6.4 MVCC"></a>6.4 MVCC</h2><h3 id="6-4-1-基本概念"><a href="#6-4-1-基本概念" class="headerlink" title="6.4.1 基本概念"></a>6.4.1 基本概念</h3><p>1). 当前读<br>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读。</p>
<p>2). 快照读<br>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p>
<ul>
<li>Read Committed：每次select，都生成一个快照读。</li>
<li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li>
<li>Serializable：快照读会退化为当前读。</li>
</ul>
<p>3). MVCC<br>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p>
<p>接下来，我们再来介绍一下InnoDB引擎的表中涉及到的隐藏字段 、undolog 以及 readview，从而来介绍一下MVCC的原理。</p>
<h3 id="6-4-2-隐藏字段"><a href="#6-4-2-隐藏字段" class="headerlink" title="6.4.2 隐藏字段"></a>6.4.2 隐藏字段</h3><h4 id="6-4-2-1-介绍"><a href="#6-4-2-1-介绍" class="headerlink" title="6.4.2.1 介绍"></a>6.4.2.1 介绍</h4><p><img src="/images/%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5.jpg" alt="隐藏字段"><br>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p>
<table>
<thead>
<tr>
<th>隐藏字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DB_TRX_ID</td>
<td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td>
</tr>
<tr>
<td>DB_ROLL_PTR</td>
<td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</td>
</tr>
<tr>
<td>DB_ROW_ID</td>
<td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td>
</tr>
</tbody></table>
<p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</p>
<h3 id="6-4-3-undolog"><a href="#6-4-3-undolog" class="headerlink" title="6.4.3 undolog"></a>6.4.3 undolog</h3><h4 id="6-4-3-1-介绍"><a href="#6-4-3-1-介绍" class="headerlink" title="6.4.3.1 介绍"></a>6.4.3.1 介绍</h4><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。<br>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。<br>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p>
<h4 id="6-4-3-2-版本链"><a href="#6-4-3-2-版本链" class="headerlink" title="6.4.3.2 版本链"></a>6.4.3.2 版本链</h4><p>有一张表原始数据为：<br><img src="/images/%E5%9B%9B%E4%B8%AA%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A11.jpg" alt="四个并发事务1"><br>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。<br>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p>
<p>然后，有四个并发事务同时在访问这张表。<br>A. 第一步<br><img src="/images/%E5%9B%9B%E4%B8%AA%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A12.jpg" alt="四个并发事务2"><br>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。<br><img src="/images/%E5%9B%9B%E4%B8%AA%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A13.jpg" alt="四个并发事务3"><br>B.第二步<br>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。<br><img src="/images/%E5%9B%9B%E4%B8%AA%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A14.jpg" alt="四个并发事务4"><br>C. 第三步<br><img src="/images/%E5%9B%9B%E4%B8%AA%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A15.jpg" alt="四个并发事务5"><br>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。<br><img src="/images/%E5%9B%9B%E4%B8%AA%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A16.jpg" alt="四个并发事务6"><br>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p>
<h3 id="6-4-4-readview"><a href="#6-4-4-readview" class="headerlink" title="6.4.4 readview"></a>6.4.4 readview</h3><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。<br>ReadView中包含了四个核心字段：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>m_ids</td>
<td>当前活跃的事务ID集合</td>
</tr>
<tr>
<td>min_trx_id</td>
<td>最小活跃事务ID</td>
</tr>
<tr>
<td>max_trx_id</td>
<td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>ReadView创建者的事务ID</td>
</tr>
</tbody></table>
<p>而在readview中就规定了版本链数据的访问规则：<br>trx_id 代表当前undolog版本链对应事务ID。</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>是否可以访问</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>trx_id == creator_trx_id</td>
<td>可以访问该版本</td>
<td>成立，说明数据是当前这个事务更改的。</td>
</tr>
<tr>
<td>trx_id &lt; min_trx_id</td>
<td>可以访问该版本</td>
<td>成立，说明数据已经提交了。</td>
</tr>
<tr>
<td>trx_id &gt; max_trx_id</td>
<td>不可以访问该版本</td>
<td>成立，说明该事务是在ReadView生成后才开启。</td>
</tr>
<tr>
<td>min_trx_id &lt;= trx_id &lt;= max_trx_id</td>
<td>如果trx_id不在m_ids中，是可以访问该版本的</td>
<td>成立，说明数据已经提交。</td>
</tr>
</tbody></table>
<p>不同的隔离级别，生成ReadView的时机不同：</p>
<ul>
<li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li>
<li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li>
</ul>
<h3 id="6-4-5-原理分析"><a href="#6-4-5-原理分析" class="headerlink" title="6.4.5 原理分析"></a>6.4.5 原理分析</h3><h4 id="6-4-5-1-RC隔离级别"><a href="#6-4-5-1-RC隔离级别" class="headerlink" title="6.4.5.1 RC隔离级别"></a>6.4.5.1 RC隔离级别</h4><p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。<br>我们就来分析事务5中，两次快照读读取数据，是如何获取数据的?<br>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读都会生成一个ReadView，那么两次生成的ReadView如下。<br><img src="/images/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB1.jpg" alt="RC隔离级别1"><br>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，到undolog版本链中匹配数据，最终决定此次快照读返回的数据。<br>A. 先来看第一次快照读具体的读取过程：<br><img src="/images/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB2.jpg" alt="RC隔离级别2"><br><img src="/images/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB3.jpg" alt="RC隔离级别3"><br>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：<br><img src="/images/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB4.jpg" alt="RC隔离级别4"><br>B. 再来看第二次快照读具体的读取过程:<br><img src="/images/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB2.jpg" alt="RC隔离级别2"><br><img src="/images/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB3.jpg" alt="RC隔离级别3"><br>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：<br><img src="/images/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB5.jpg" alt="RC隔离级别5"><br>6.4.5.3 RR隔离级别<br>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。<br>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了<br><img src="/images/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB6.jpg" alt="RC隔离级别6"><br>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的。</p>
<p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。<br><img src="/images/MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.jpg" alt="MVCC的实现原理"></p>
<h1 id="7-MySQL管理"><a href="#7-MySQL管理" class="headerlink" title="7. MySQL管理"></a>7. MySQL管理</h1><h2 id="7-1-系统数据库"><a href="#7-1-系统数据库" class="headerlink" title="7.1 系统数据库"></a>7.1 系统数据库</h2><p>Mysql数据库安装完成后，自带了一下四个数据库，具体作用如下：</p>
<table>
<thead>
<tr>
<th>数据库</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>mysql</td>
<td>存储MySQL服务器正常运行所需要的各种信息 （时区、主从、用户、权限等）</td>
</tr>
<tr>
<td>information_schema</td>
<td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等</td>
</tr>
<tr>
<td>performance_schema</td>
<td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td>
</tr>
<tr>
<td>sys</td>
<td>包含了一系列方便 DBA 和开发人员利用 performance_schema性能数据库进行性能调优和诊断的视图</td>
</tr>
</tbody></table>
<h2 id="7-2-常用工具"><a href="#7-2-常用工具" class="headerlink" title="7.2 常用工具"></a>7.2 常用工具</h2><h3 id="7-2-1-mysql"><a href="#7-2-1-mysql" class="headerlink" title="7.2.1 mysql"></a>7.2.1 mysql</h3><p>该mysql不是指mysql服务，而是指mysql的客户端工具。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">语法 ：
  mysql <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>database<span class="token punctuation">]</span>
选项 ：
  <span class="token operator">-</span>u<span class="token punctuation">,</span> <span class="token operator">--</span>user<span class="token operator">=</span>name #指定用户名
  <span class="token operator">-</span>p<span class="token punctuation">,</span> <span class="token operator">--</span>password<span class="token punctuation">[</span><span class="token operator">=</span>name<span class="token punctuation">]</span> #指定密码
  <span class="token operator">-</span>h<span class="token punctuation">,</span> <span class="token operator">--</span>host<span class="token operator">=</span>name #指定服务器IP或域名
  <span class="token operator">-</span><span class="token class-name">P</span><span class="token punctuation">,</span> <span class="token operator">--</span>port<span class="token operator">=</span>port #指定连接端口
  <span class="token operator">-</span>e<span class="token punctuation">,</span> <span class="token operator">--</span>execute<span class="token operator">=</span>name #执行SQL语句并退出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>-e选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。<br>示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">mysql <span class="token operator">-</span>uroot –p123456 db01 <span class="token operator">-</span>e <span class="token string">"select * from stu"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="7-2-2-mysqladmin"><a href="#7-2-2-mysqladmin" class="headerlink" title="7.2.2 mysqladmin"></a>7.2.2 mysqladmin</h3><p>mysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">通过帮助文档查看选项：
mysqladmin <span class="token operator">--</span>help<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">语法<span class="token operator">:</span>
  mysqladmin <span class="token punctuation">[</span>options<span class="token punctuation">]</span> command <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
选项<span class="token operator">:</span>
  <span class="token operator">-</span>u<span class="token punctuation">,</span> <span class="token operator">--</span>user<span class="token operator">=</span>name #指定用户名
  <span class="token operator">-</span>p<span class="token punctuation">,</span> <span class="token operator">--</span>password<span class="token punctuation">[</span><span class="token operator">=</span>name<span class="token punctuation">]</span> #指定密码
  <span class="token operator">-</span>h<span class="token punctuation">,</span> <span class="token operator">--</span>host<span class="token operator">=</span>name #指定服务器IP或域名
  <span class="token operator">-</span><span class="token class-name">P</span><span class="token punctuation">,</span> <span class="token operator">--</span>port<span class="token operator">=</span>port #指定连接端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">mysqladmin <span class="token operator">-</span>uroot –p1234 drop <span class="token char">'test01'</span><span class="token punctuation">;</span>
mysqladmin <span class="token operator">-</span>uroot –p1234 version<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="7-2-3-mysqlbinlog"><a href="#7-2-3-mysqlbinlog" class="headerlink" title="7.2.3 mysqlbinlog"></a>7.2.3 mysqlbinlog</h3><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">语法 ：
  mysqlbinlog <span class="token punctuation">[</span>options<span class="token punctuation">]</span> log<span class="token operator">-</span>files1 log<span class="token operator">-</span>files2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
选项 ：
  <span class="token operator">-</span>d<span class="token punctuation">,</span> <span class="token operator">--</span>database<span class="token operator">=</span>name 指定数据库名称，只列出指定的数据库相关操作。
  <span class="token operator">-</span>o<span class="token punctuation">,</span> <span class="token operator">--</span>offset<span class="token operator">=</span># 忽略掉日志中的前n行命令。
  <span class="token operator">-</span>r<span class="token punctuation">,</span><span class="token operator">--</span>result<span class="token operator">-</span>file<span class="token operator">=</span>name 将输出的文本格式日志输出到指定文件。
  <span class="token operator">-</span>s<span class="token punctuation">,</span> <span class="token operator">--</span><span class="token keyword">short</span><span class="token operator">-</span>form 显示简单格式， 省略掉一些信息。
  <span class="token operator">--</span>start<span class="token operator">-</span>datatime<span class="token operator">=</span>date1 <span class="token operator">--</span>stop<span class="token operator">-</span>datetime<span class="token operator">=</span>date2 指定日期间隔内的所有日志。
  <span class="token operator">--</span>start<span class="token operator">-</span>position<span class="token operator">=</span>pos1 <span class="token operator">--</span>stop<span class="token operator">-</span>position<span class="token operator">=</span>pos2 指定位置间隔内的所有日志。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="7-2-4-mysqlshow"><a href="#7-2-4-mysqlshow" class="headerlink" title="7.2.4 mysqlshow"></a>7.2.4 mysqlshow</h3><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">语法 ：
  mysqlshow <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>db_name <span class="token punctuation">[</span>table_name <span class="token punctuation">[</span>col_name<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
选项 ：
  <span class="token operator">--</span>count 显示数据库及表的统计信息（数据库，表 均可以不指定）
  <span class="token operator">-</span>i 显示指定数据库或者指定表的状态信息
示例：
  #查询test库中每个表中的字段书，及行数
  mysqlshow <span class="token operator">-</span>uroot <span class="token operator">-</span>p2143 test <span class="token operator">--</span>count
  #查询test库中book表的详细情况
  mysqlshow <span class="token operator">-</span>uroot <span class="token operator">-</span>p2143 test book <span class="token operator">--</span>count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例：<br>A. 查询每个数据库的表的数量及表中记录的数量<br>mysqlshow -uroot -p1234 –count<br>B. 查看数据库db01的统计信息<br>mysqlshow -uroot -p1234 db01 –count<br>C. 查看数据库db01中的course表的信息<br>mysqlshow -uroot -p1234 db01 course –count<br>D. 查看数据库db01中的course表的id字段的信息<br>mysqlshow -uroot -p1234 db01 course id –count</p>
<h3 id="7-2-5-mysqldump"><a href="#7-2-5-mysqldump" class="headerlink" title="7.2.5 mysqldump"></a>7.2.5 mysqldump</h3><p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">语法 ：
  mysqldump <span class="token punctuation">[</span>options<span class="token punctuation">]</span> db_name <span class="token punctuation">[</span>tables<span class="token punctuation">]</span>
  mysqldump <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token operator">--</span>database<span class="token operator">/</span><span class="token operator">-</span><span class="token class-name">B</span> db1 <span class="token punctuation">[</span>db2 db3<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
  mysqldump <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token operator">--</span>all<span class="token operator">-</span>databases<span class="token operator">/</span><span class="token operator">-</span><span class="token class-name">A</span>
连接选项 ：
  <span class="token operator">-</span>u<span class="token punctuation">,</span> <span class="token operator">--</span>user<span class="token operator">=</span>name 指定用户名
  <span class="token operator">-</span>p<span class="token punctuation">,</span> <span class="token operator">--</span>password<span class="token punctuation">[</span><span class="token operator">=</span>name<span class="token punctuation">]</span> 指定密码
  <span class="token operator">-</span>h<span class="token punctuation">,</span> <span class="token operator">--</span>host<span class="token operator">=</span>name 指定服务器ip或域名
  <span class="token operator">-</span><span class="token class-name">P</span><span class="token punctuation">,</span> <span class="token operator">--</span>port<span class="token operator">=</span># 指定连接端口
输出选项：
  <span class="token operator">--</span>add<span class="token operator">-</span>drop<span class="token operator">-</span>database 在每个数据库创建语句前加上 drop database 语句
  <span class="token operator">--</span>add<span class="token operator">-</span>drop<span class="token operator">-</span>table 在每个表创建语句前加上 drop table 语句 <span class="token punctuation">,</span> 默认开启 <span class="token punctuation">;</span> 不
开启 <span class="token punctuation">(</span><span class="token operator">--</span>skip<span class="token operator">-</span>add<span class="token operator">-</span>drop<span class="token operator">-</span>table<span class="token punctuation">)</span>
  <span class="token operator">-</span>n<span class="token punctuation">,</span> <span class="token operator">--</span>no<span class="token operator">-</span>create<span class="token operator">-</span>db 不包含数据库的创建语句
  <span class="token operator">-</span>t<span class="token punctuation">,</span> <span class="token operator">--</span>no<span class="token operator">-</span>create<span class="token operator">-</span>info 不包含数据表的创建语句
  <span class="token operator">-</span>d <span class="token operator">--</span>no<span class="token operator">-</span>data 不包含数据
  <span class="token operator">-</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token operator">--</span>tab<span class="token operator">=</span>name 自动生成两个文件：一个<span class="token punctuation">.</span>sql文件，创建表结构的语句；一个<span class="token punctuation">.</span>txt文件，数据文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例:<br>A. 备份db01数据库<br>mysqldump -uroot -p1234 db01 &gt; db01.sql<br>可以直接打开db01.sql，来查看备份出来的数据到底什么样。<br>备份出来的数据包含：</p>
<ul>
<li>删除表的语句</li>
<li>创建表的语句</li>
<li>数据插入语句<br>如果我们在数据备份时，不需要创建表，或者不需要备份数据，只需要备份表结构，都可以通过对应的参数来实现。<br>B. 备份db01数据库中的表数据，不备份表结构(-t)<br>mysqldump -uroot -p1234 -t db01 &gt; db01.sql<br>打开 db02.sql ，来查看备份的数据，只有insert语句，没有备份表结构。<br>C. 将db01数据库的表的表结构与数据分开备份(-T)<br>mysqldump -uroot -p1234 -T /root db01 score<br>执行上述指令，会出错，数据不能完成备份，原因是因为我们所指定的数据存放目录/root，MySQL认为是不安全的，需要存储在MySQL信任的目录下。那么，哪个目录才是MySQL信任的目录呢，可以查看一下系统变量 secure_file_priv 。<br>上述的两个文件 score.sql 中记录的就是表结构文件，而 score.txt 就是表数据文件，但是需要注意表数据文件，并不是记录一条条的insert语句，而是按照一定的格式记录表结构中的数据。</li>
</ul>
<h3 id="7-2-6-mysqlimport-x2F-source"><a href="#7-2-6-mysqlimport-x2F-source" class="headerlink" title="7.2.6 mysqlimport/source"></a>7.2.6 mysqlimport/source</h3><p>1). mysqlimport<br>mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">语法 ：
  mysqlimport <span class="token punctuation">[</span>options<span class="token punctuation">]</span> db_name textfile1 <span class="token punctuation">[</span>textfile2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
示例 ：
  mysqlimport <span class="token operator">-</span>uroot <span class="token operator">-</span>p2143 test <span class="token operator">/</span>tmp<span class="token operator">/</span>city<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>2). source<br>如果需要导入sql文件,可以使用mysql中的source 指令 :</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">语法 ：
  source <span class="token operator">/</span>root<span class="token operator">/</span>xxxxx<span class="token punctuation">.</span>sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">wb</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://wangbin5920.github.io/2021/05/15/mysql-jin-jie/">http://wangbin5920.github.io/2021/05/15/mysql-jin-jie/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">wb</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/MySQL-%E8%BF%9B%E9%98%B6/">
                                    <span class="chip bg-color">MySQL 进阶</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/05/15/mysql-ji-chu/">
                    <div class="card-image">
                        
                        <img src="/images/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg" class="responsive-img" alt="MySQL 基础">
                        
                        <span class="card-title">MySQL 基础</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            MySQL 是一款安全、跨平台、高效的，并与 PHP、Java 等主流编程语言紧密结合的数据库系统。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-05-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-category">
                                    数据库
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/MySQL-%E5%9F%BA%E7%A1%80/">
                        <span class="chip bg-color">MySQL 基础</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/05/15/mysql-yun-wei/">
                    <div class="card-image">
                        
                        <img src="/images/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg" class="responsive-img" alt="MySQL 运维">
                        
                        <span class="card-title">MySQL 运维</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            MySQL 是一款安全、跨平台、高效的，并与 PHP、Java 等主流编程语言紧密结合的数据库系统。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-05-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-category">
                                    数据库
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/MySQL-%E8%BF%90%E7%BB%B4/">
                        <span class="chip bg-color">MySQL 运维</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2022</span>
            
            <a href="/about" target="_blank">王斌</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">127.8k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2021";
                        var startMonth = "3";
                        var startDate = "15";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/wangbin5920" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:375314196@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=375314196" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 375314196" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
